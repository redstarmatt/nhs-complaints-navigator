const express = require('express');
const path = require('path');
const PDFDocument = require('pdfkit');
const { Document, Packer, Paragraph, TextRun, AlignmentType } = require('docx');
const nodemailer = require('nodemailer');

const app = express();
const PORT = process.env.PORT || 3000;

// Sanitise error objects to strip personal data from logs
function sanitiseError(err) {
  if (!err) return 'Unknown error';
  const msg = err.message || String(err);
  // Strip potential postcodes, NHS numbers, NI numbers, email addresses
  return msg
    .replace(/\b[A-Z]{1,2}\d[A-Z\d]?\s?\d[A-Z]{2}\b/gi, '[POSTCODE]')
    .replace(/\b\d{3}\s?\d{3}\s?\d{4}\b/g, '[NHS_NUMBER]')
    .replace(/\b[A-Z]{2}\s?\d{2}\s?\d{2}\s?\d{2}\s?[A-D]\b/gi, '[NI_NUMBER]')
    .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z]{2,}\b/gi, '[EMAIL]');
}

const GEMINI_API_URL =
  'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

// ── In-memory rate limiter (per IP, for /api/chat) ──
const RATE_LIMIT_WINDOW_MS = 60 * 1000; // 1 minute
const RATE_LIMIT_MAX = 20;              // max requests per window
const rateLimitStore = new Map();       // IP → { count, resetTime }

// Prune stale entries every 5 minutes to prevent memory leak
setInterval(() => {
  const now = Date.now();
  for (const [ip, entry] of rateLimitStore) {
    if (now > entry.resetTime) rateLimitStore.delete(ip);
  }
}, 5 * 60 * 1000);

function rateLimiter(req, res, next) {
  const ip = req.ip || req.socket.remoteAddress || 'unknown';
  const now = Date.now();
  let entry = rateLimitStore.get(ip);

  if (!entry || now > entry.resetTime) {
    entry = { count: 0, resetTime: now + RATE_LIMIT_WINDOW_MS };
    rateLimitStore.set(ip, entry);
  }

  entry.count++;

  res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX);
  res.setHeader('X-RateLimit-Remaining', Math.max(0, RATE_LIMIT_MAX - entry.count));
  res.setHeader('X-RateLimit-Reset', Math.ceil(entry.resetTime / 1000));

  if (entry.count > RATE_LIMIT_MAX) {
    return res.status(429).json({ error: 'Too many requests. Please wait a moment before trying again.' });
  }

  next();
}

// Serve static files from project root
app.use(express.static(path.join(__dirname)));
app.use(express.json({ limit: '1mb' }));

// Proxy chat requests to Gemini API (rate-limited)
app.post('/api/chat', rateLimiter, async (req, res) => {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    return res.status(500).json({ error: 'Server misconfigured: no GEMINI_API_KEY set.' });
  }

  const { systemPrompt, history, userMessage } = req.body;
  if (!systemPrompt || !userMessage) {
    return res.status(400).json({ error: 'Missing systemPrompt or userMessage.' });
  }

  // Build Gemini request body
  const contents = [];
  if (Array.isArray(history)) {
    for (const msg of history) {
      contents.push({
        role: msg.role === 'ai' ? 'model' : msg.role,
        parts: [{ text: msg.text }]
      });
    }
  }
  contents.push({ role: 'user', parts: [{ text: userMessage }] });

  const body = {
    system_instruction: { parts: [{ text: systemPrompt }] },
    contents,
    generationConfig: {
      temperature: 0.7,
      topP: 0.95,
      maxOutputTokens: 3072
    }
  };

  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const status = response.status;
      let message = `Gemini API error (${status}).`;
      if (status === 400) message = 'Invalid request to Gemini API.';
      if (status === 403) message = 'Gemini API access denied. Check server API key.';
      if (status === 429) message = 'Rate limit reached. Please wait a moment.';
      if (status >= 500) message = 'Gemini API server error.';
      return res.status(502).json({ error: message });
    }

    const data = await response.json();
    const candidate = data.candidates?.[0];
    if (!candidate) {
      return res.status(502).json({ error: 'No response generated by Gemini.' });
    }

    const text = candidate.content?.parts?.map(p => p.text).join('') || '';
    if (!text) {
      return res.status(502).json({ error: 'Empty response from Gemini.' });
    }

    res.json({ text });
  } catch (err) {
    console.error('Gemini proxy error:', sanitiseError(err));
    res.status(502).json({ error: 'Could not reach Gemini API.' });
  }
});

// Generate PDF from letter text
app.post('/api/generate-pdf', (req, res) => {
  const { letterText } = req.body;
  if (!letterText) {
    return res.status(400).json({ error: 'Missing letterText.' });
  }

  try {
    const doc = new PDFDocument({
      size: 'A4',
      margins: { top: 72, bottom: 72, left: 72, right: 72 }
    });

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="complaint-letter-${new Date().toISOString().slice(0, 10)}.pdf"`);

    doc.pipe(res);

    // Header
    doc.font('Helvetica-Bold').fontSize(11).text('Complaint Letter', { align: 'center' });
    doc.moveDown(0.5);
    doc.font('Helvetica').fontSize(9).fillColor('#666666').text(
      `Generated on ${new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}`,
      { align: 'center' }
    );
    doc.moveDown(1.5);

    // Divider line
    doc.strokeColor('#cccccc').lineWidth(0.5)
      .moveTo(72, doc.y).lineTo(523, doc.y).stroke();
    doc.moveDown(1);

    // Body text
    doc.font('Helvetica').fontSize(11).fillColor('#1a2332');
    const paragraphs = letterText.split(/\n\n+/);
    paragraphs.forEach((para, i) => {
      const lines = para.split('\n');
      lines.forEach(line => {
        doc.text(line.trim(), { lineGap: 4 });
      });
      if (i < paragraphs.length - 1) {
        doc.moveDown(0.8);
      }
    });

    doc.end();
  } catch (err) {
    console.error('PDF generation error:', sanitiseError(err));
    if (!res.headersSent) {
      res.status(500).json({ error: 'Failed to generate PDF.' });
    }
  }
});

// Generate DOCX from letter text
app.post('/api/generate-docx', async (req, res) => {
  const { letterText } = req.body;
  if (!letterText) {
    return res.status(400).json({ error: 'Missing letterText.' });
  }

  try {
    const paragraphs = letterText.split(/\n\n+/);
    const docParagraphs = [];

    // Title
    docParagraphs.push(new Paragraph({
      children: [new TextRun({ text: 'Complaint Letter', bold: true, size: 28, font: 'Arial' })],
      alignment: AlignmentType.CENTER,
      spacing: { after: 100 }
    }));

    // Date
    docParagraphs.push(new Paragraph({
      children: [new TextRun({
        text: `Generated on ${new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}`,
        size: 20,
        font: 'Arial',
        color: '666666'
      })],
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    }));

    // Body paragraphs
    paragraphs.forEach(para => {
      const lines = para.split('\n');
      const children = [];
      lines.forEach((line, i) => {
        if (i > 0) children.push(new TextRun({ text: '', break: 1 }));
        children.push(new TextRun({ text: line.trim(), size: 24, font: 'Arial' }));
      });
      docParagraphs.push(new Paragraph({
        children,
        spacing: { after: 200, line: 360 }
      }));
    });

    const doc = new Document({
      sections: [{
        properties: {
          page: {
            margin: {
              top: 1440,    // 1 inch = 1440 twips
              right: 1440,
              bottom: 1440,
              left: 1440
            }
          }
        },
        children: docParagraphs
      }]
    });

    const buffer = await Packer.toBuffer(doc);
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
    res.setHeader('Content-Disposition', `attachment; filename="complaint-letter-${new Date().toISOString().slice(0, 10)}.docx"`);
    res.send(buffer);
  } catch (err) {
    console.error('DOCX generation error:', sanitiseError(err));
    res.status(500).json({ error: 'Failed to generate Word document.' });
  }
});

// Send email with letter as attachment
app.post('/api/send-email', async (req, res) => {
  const emailUser = process.env.EMAIL_USER;
  const emailPass = process.env.EMAIL_APP_PASSWORD;

  if (!emailUser || !emailPass) {
    return res.status(500).json({ error: 'Email sending is not configured on this server. Please download the letter and send it manually.' });
  }

  const { to, subject, letterText } = req.body;
  if (!to || !subject || !letterText) {
    return res.status(400).json({ error: 'Missing required fields: to, subject, letterText.' });
  }

  try {
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: emailUser,
        pass: emailPass
      }
    });

    // Generate PDF attachment
    const pdfBuffer = await new Promise((resolve, reject) => {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 72, bottom: 72, left: 72, right: 72 }
      });
      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      doc.font('Helvetica-Bold').fontSize(11).text('Complaint Letter', { align: 'center' });
      doc.moveDown(0.5);
      doc.font('Helvetica').fontSize(9).fillColor('#666666').text(
        `Generated on ${new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}`,
        { align: 'center' }
      );
      doc.moveDown(1.5);
      doc.strokeColor('#cccccc').lineWidth(0.5)
        .moveTo(72, doc.y).lineTo(523, doc.y).stroke();
      doc.moveDown(1);
      doc.font('Helvetica').fontSize(11).fillColor('#1a2332');
      const paragraphs = letterText.split(/\n\n+/);
      paragraphs.forEach((para, i) => {
        const lines = para.split('\n');
        lines.forEach(line => {
          doc.text(line.trim(), { lineGap: 4 });
        });
        if (i < paragraphs.length - 1) {
          doc.moveDown(0.8);
        }
      });
      doc.end();
    });

    const dateStr = new Date().toISOString().slice(0, 10);

    await transporter.sendMail({
      from: emailUser,
      to,
      subject,
      text: letterText,
      attachments: [
        {
          filename: `complaint-letter-${dateStr}.pdf`,
          content: pdfBuffer,
          contentType: 'application/pdf'
        },
        {
          filename: `complaint-letter-${dateStr}.txt`,
          content: letterText,
          contentType: 'text/plain'
        }
      ]
    });

    res.json({ success: true, message: 'Email sent successfully.' });
  } catch (err) {
    console.error('Email send error:', sanitiseError(err));
    res.status(500).json({ error: 'Failed to send email. Please download the letter and send it manually.' });
  }
});

// Postcode lookup — proxy to Postcodes.io
app.get('/api/postcode/:postcode', async (req, res) => {
  const postcode = req.params.postcode.trim().replace(/\s+/g, '');
  // Basic UK postcode validation
  if (!/^[A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2}$/i.test(postcode)) {
    return res.status(400).json({ error: 'Invalid UK postcode format.' });
  }

  try {
    const response = await fetch(`https://api.postcodes.io/postcodes/${encodeURIComponent(postcode)}`);
    if (!response.ok) {
      return res.status(404).json({ error: 'Postcode not found.' });
    }
    const data = await response.json();
    if (data.status !== 200 || !data.result) {
      return res.status(404).json({ error: 'Postcode not found.' });
    }

    const r = data.result;
    res.json({
      council: r.admin_district || null,
      icb: r.ccg || null,
      policeForce: r.pfa || null,
      country: r.country || 'England'
    });
  } catch (err) {
    console.error('Postcode lookup error:', sanitiseError(err));
    res.status(502).json({ error: 'Could not reach postcode lookup service.' });
  }
});

// MP lookup — proxy to UK Parliament Members API
app.get('/api/mp/:postcode', async (req, res) => {
  const postcode = req.params.postcode.trim();

  try {
    const response = await fetch(`https://members-api.parliament.uk/api/Members/Search?PostcodeSearch=${encodeURIComponent(postcode)}&House=1`);
    if (!response.ok) {
      return res.status(502).json({ error: 'Could not reach Parliament Members API.' });
    }
    const data = await response.json();
    const items = data.items;
    if (!items || items.length === 0) {
      return res.status(404).json({ error: 'No MP found for this postcode.' });
    }

    const member = items[0].value;
    res.json({
      name: member.nameDisplayAs || null,
      party: member.latestParty?.name || null,
      constituency: member.latestHouseMembership?.membershipFrom || null,
      thumbnailUrl: member.thumbnailUrl || null
    });
  } catch (err) {
    console.error('MP lookup error:', sanitiseError(err));
    res.status(502).json({ error: 'Could not reach Parliament Members API.' });
  }
});

app.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT}`);
});
